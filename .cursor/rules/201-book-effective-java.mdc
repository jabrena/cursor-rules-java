---
description: Java rules from the book "Effective Java"
globs: **/*.java
alwaysApply: false
---
# Effective Java Guidelines

## Table of Contents

### Chapter 2: Creating and Destroying Objects
1. Rule: Consider static factory methods instead of constructors
2. Rule: Consider a builder when faced with many constructor parameters
3. Rule: Enforce the singleton property with a private constructor or an enum type
4. Rule: Enforce noninstantiability with a private constructor
5. Rule: Prefer dependency injection to hardwiring resources
6. Rule: Avoid creating unnecessary objects
7. Rule: Eliminate obsolete object references
8. Rule: Avoid finalizers and cleaners
9. Rule: Prefer try-with-resources to try-finally

### Chapter 3: Methods Common to All Objects
1. Rule: Obey the general contract when overriding equals
2. Rule: Always override hashCode when you override equals
3. Rule: Always override toString
4. Rule: Override clone judiciously
5. Rule: Consider implementing Comparable

### Chapter 4: Classes and Interfaces
1. Rule: Minimize the accessibility of classes and members
2. Rule: In public classes, use accessor methods, not public fields
3. Rule: Minimize mutability
4. Rule: Favor composition over inheritance
5. Rule: Design and document for inheritance or else prohibit it
6. Rule: Prefer interfaces to abstract classes
7. Rule: Design interfaces for posterity
8. Rule: Use interfaces only to define types
9. Rule: Prefer class hierarchies to tagged classes
10. Rule: Favor static member classes over nonstatic
11. Rule: Limit source files to a single top-level class

### Chapter 5: Generics
1. Rule: Don't use raw types
2. Rule: Eliminate unchecked warnings
3. Rule: Prefer lists to arrays
4. Rule: Favor generic types
5. Rule: Favor generic methods
6. Rule: Use bounded wildcards to increase API flexibility
7. Rule: Combine generics and varargs judiciously
8. Rule: Consider typesafe heterogeneous containers

### Chapter 6: Enums and Annotations
1. Rule: Use enums instead of int constants
2. Rule: Use instance fields instead of ordinals
3. Rule: Use EnumSet instead of bit fields
4. Rule: Use EnumMap instead of ordinal indexing
5. Rule: Emulate extensible enums with interfaces
6. Rule: Prefer annotations to naming patterns
7. Rule: Consistently use the Override annotation
8. Rule: Use marker interfaces to define types

### Chapter 7: Lambdas and Streams
1. Rule: Prefer lambdas to anonymous classes
2. Rule: Prefer method references to lambdas
3. Rule: Favor the use of standard functional interfaces
4. Rule: Use streams judiciously
5. Rule: Prefer side-effect-free functions in streams
6. Rule: Prefer Collection to Stream as a return type
7. Rule: Use caution when making streams parallel

### Chapter 8: Methods
1. Rule: Check parameters for validity
2. Rule: Make defensive copies when needed
3. Rule: Design method signatures carefully
4. Rule: Use overloading judiciously
5. Rule: Use varargs judiciously
6. Rule: Return empty collections or arrays, not nulls
7. Rule: Return optionals judiciously
8. Rule: Write doc comments for all exposed API elements

### Chapter 9: General Programming
1. Rule: Minimize the scope of local variables
2. Rule: Prefer for-each loops to traditional for loops
3. Rule: Know and use the libraries
4. Rule: Avoid float and double if exact answers are required
5. Rule: Prefer primitive types to boxed primitives
6. Rule: Avoid strings where other types are more appropriate
7. Rule: Beware the performance of string concatenation
8. Rule: Refer to objects by their interfaces
9. Rule: Prefer interfaces to reflection
10. Rule: Use native methods judiciously
11. Rule: Optimize judiciously
12. Rule: Adhere to generally accepted naming conventions

### Chapter 10: Exceptions
1. Rule: Use exceptions only for exceptional conditions
2. Rule: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors
3. Rule: Avoid unnecessary use of checked exceptions
4. Rule: Favor the use of standard exceptions
5. Rule: Throw exceptions appropriate to the abstraction
6. Rule: Document all exceptions thrown by each method
7. Rule: Include failure-capture information in detail messages
8. Rule: Strive for failure atomicity
9. Rule: Don't ignore exceptions

### Chapter 11: Concurrency
1. Rule: Synchronize access to shared mutable data
2. Rule: Avoid excessive synchronization
3. Rule: Prefer executors, tasks, and streams to threads
4. Rule: Prefer concurrency utilities to wait and notify
5. Rule: Document thread safety
6. Rule: Use lazy initialization judiciously
7. Rule: Don't depend on the thread scheduler

### Chapter 12: Serialization
1. Rule: Prefer alternatives to Java serialization
2. Rule: Implement Serializable with great caution
3. Rule: Consider using a custom serialized form
4. Rule: Write readObject methods defensively
5. Rule: For instance control, prefer enum types to readResolve
6. Rule: Consider serialization proxies instead of serialized instances
