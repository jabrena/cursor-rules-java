---
description: Java Integration testing
globs: **/*IT.java
alwaysApply: false
---

# Java Integration Testing Guidelines

These guidelines aim to ensure consistency, reliability, and maintainability of integration tests within the project.

## 1. Scope and Purpose

*   **Rule:** Integration tests verify the interaction between multiple components or systems (e.g., service layer with database, service-to-service communication over HTTP).
*   **Guideline:** Clearly define the boundary of each integration test. What specific interaction or flow is being tested?
*   **Guideline:** Prefer integration tests for verifying contracts between services (APIs) and interactions with external dependencies (databases, message queues, etc.). Avoid replicating complex business logic already covered by unit tests.

## 2. Test Environment & Dependencies (Testcontainers)

*   **Rule:** Use Testcontainers (`org.testcontainers:testcontainers`) to manage external dependencies (databases, message brokers, caches, other services) required for the test. Avoid relying on pre-existing external environments.
*   **Rule:** Declare containerized dependencies using `@Testcontainers` and `@Container` annotations for JUnit 5 integration (`org.testcontainers:junit-jupiter`). Manage container lifecycles appropriately (per test suite or per test method, favoring suite-level for performance).
    *   *Example:* Use a static `@Container` field for a database shared across all tests in a class.
    *   *Example Code (Database):*
        ```java
        import org.junit.jupiter.api.Test;
        import org.springframework.boot.test.context.SpringBootTest;
        import org.springframework.test.context.DynamicPropertyRegistry;
        import org.springframework.test.context.DynamicPropertySource;
        import org.testcontainers.containers.PostgreSQLContainer;
        import org.testcontainers.junit.jupiter.Container;
        import org.testcontainers.junit.jupiter.Testcontainers;

        @Testcontainers
        @SpringBootTest // Or relevant test context setup
        class MyRepositoryIT {

            @Container // Static -> shared container for all tests in this class
            static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine");

            // Dynamically set properties based on container info
            @DynamicPropertySource
            static void configureProperties(DynamicPropertyRegistry registry) {
                registry.add("spring.datasource.url", postgres::getJdbcUrl);
                registry.add("spring.datasource.username", postgres::getUsername);
                registry.add("spring.datasource.password", postgres::getPassword);
            }

            // Inject your repository/service here
            // @Autowired
            // private MyRepository repository;

            @Test
            void should_connectAndInteractWithDatabase() {
                // Test logic interacting with the repository,
                // which uses the Testcontainer database
                assertThat(postgres.isRunning()).isTrue();
                // ... perform repository operations and assertions ...
            }
        }
        ```
*   **Guideline:** Use official or well-maintained Docker images for dependencies. Pin image versions (e.g., `"postgres:15-alpine"`) to ensure reproducible builds.
*   **Guideline:** Configure containers programmatically (ports, environment variables, wait strategies) within the test setup. Use `Wait.for...` strategies (e.g., `Wait.forHttp("/health")`, `Wait.forLogMessage(...)`) to ensure containers are ready before tests run.
*   **Rule:** Inject dynamic container properties (like mapped ports or JDBC URLs) into the application context or test configuration.
    *   **Spring Boot:** Use `@DynamicPropertySource` with a static method.
    *   **Other:** Manually retrieve properties (e.g., `container.getMappedPort(originalPort)`, `container.getJdbcUrl()`) in `@BeforeAll` / `@BeforeEach` and configure your SUT accordingly.

## 3. API Testing (RestAssured)

*   **Rule:** Use RestAssured (`io.rest-assured:rest-assured`) for testing RESTful APIs. Structure tests using the Given/When/Then (Gherkin) syntax provided by RestAssured.
    *   `given()`: Set up request prerequisites (headers, authentication, path/query parameters, request body).
    *   `when()`: Perform the HTTP request (GET, POST, PUT, DELETE, etc.).
    *   `then()`: Validate the response (status code, headers, response body).
*   **Rule:** Always validate the HTTP status code first using `statusCode()`.
*   **Rule:** Use Hamcrest matchers (`org.hamcrest.Matchers`) or RestAssured's built-in JSON/XML path validation (`body()`) for asserting response content. Be specific but avoid overly brittle assertions (e.g., don't assert entire large JSON bodies if only a few fields matter).
    *   *Example (JSON Path):* `then().statusCode(200).body("user.id", equalTo(123), "user.name", containsString("John"));`
*   **Guideline:** Define base URIs, ports, and common paths in a setup method (`@BeforeEach` or a base test class) to avoid repetition. Set `RestAssured.baseURI`, `RestAssured.port` (often using the dynamic port from Spring Boot Test or Testcontainers).
    *   *Example (Spring Boot Test):*
        ```java
        import io.restassured.RestAssured;
        import org.junit.jupiter.api.BeforeEach;
        import org.junit.jupiter.api.Test;
        import org.springframework.boot.test.context.SpringBootTest;
        import org.springframework.boot.test.web.server.LocalServerPort;
        import static io.restassured.RestAssured.*;
        import static org.hamcrest.Matchers.*;

        @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
        class MyApiControllerIT {

            @LocalServerPort
            private int port;

            @BeforeEach
            void setUp() {
                RestAssured.baseURI = "http://localhost";
                RestAssured.port = port;
                // Optional: Set base path if all endpoints share prefix
                // RestAssured.basePath = "/api/v1";
            }

            @Test
            void getResourceById_shouldReturnOkAndResource() {
                given()
                    // .header("Authorization", "Bearer ...") // Add auth if needed
                    .pathParam("id", 123)
                .when()
                    .get("/resources/{id}")
                .then()
                    .statusCode(200)
                    .body("id", equalTo(123))
                    .body("name", equalTo("ResourceName"));
            }
        }
        ```
*   **Guideline:** Handle authentication consistently. Use RestAssured's built-in authentication mechanisms (`auth().basic()`, `auth().oauth2()`, etc.) or abstract authentication logic into helper methods/classes.
*   **Guideline:** For complex request/response bodies, use POJOs (Plain Old Java Objects) with libraries like Jackson or Gson for serialization/deserialization instead of raw strings. Pass the POJO to `body()` in `given()` and expect a POJO class in `then().extract().as()`.

## 4. Data Management

*   **Rule:** Ensure each integration test runs with a known, controlled data state. Tests must be independent.
*   **Guideline:** Seed necessary test data before each test (`@BeforeEach`) or test suite (`@BeforeAll`). Options:
    *   **Application Services:** Call repository or service methods to set up required entities.
    *   **Object Mothers / Test Data Builders:** Use patterns to create complex test data objects easily.
*   **Rule:** Clean up persistent data created during a test run to ensure test isolation. Choose one strategy:
    *   **Truncate Tables:** Execute `TRUNCATE TABLE ...` statements in `@AfterEach`. Fastest for complex state.
    *   **Transaction Rollback :** Annotate test methods or the class with `@Transactional`. Spring Test will automatically roll back the transaction after each test. Preferred for simplicity if applicable.
    *   **Delete Specific Data:** Use repository/service methods in `@AfterEach` to delete only the data created by the test (can be complex).
    *   **Container Recreation:** Recreate the database container per test or class (very slow, generally avoided).

## 5. Test Structure and Assertions

*   **Guideline:** Keep integration tests focused on a single user story, API endpoint interaction, or component integration scenario.
*   **Guideline:** Use descriptive test method names (`should_ExpectedBehavior_when_StateUnderTest` or `@DisplayName`) that clearly explain the scenario being tested.
*   **Rule:** Assertions should be specific and provide clear failure messages.
    *   **RestAssured:** Leverage Hamcrest matchers for clear assertions on response bodies.
    *   **Database State:** Use repositories/JDBC to fetch data after the action and assert its state using AssertJ.
*   **Guideline:** Use RestAssured's logging (`log().ifValidationFails()`) during development/debugging, but remove or minimize verbose logging (`log().all()`) in committed code to keep test output clean.

## 6. Performance and Cleanup

*   **Guideline:** Be mindful of integration test execution time. Container startup is the main overhead.
    *   **Prefer static `@Container` fields:** Reuses the same container for all tests in a class.
    *   **Consider Singleton Container Pattern:** For sharing a container across multiple test classes (more advanced setup).
*   **Rule:** Ensure Testcontainers resources are stopped and removed after the test suite finishes. The `testcontainers-junit-jupiter` extension handles this automatically for containers managed via `@Container`. If managing containers manually, ensure `stop()` is called in a suitable cleanup hook (`@AfterAll`).
*   **Guideline:** Separate integration tests (e.g., `*IT.java`) from unit tests (`*Test.java`) using naming conventions and configure build tools (Maven Surefire/Failsafe, Gradle) to run them in different phases if needed (integration tests often run after packaging).

